// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
)

type UserReadRepository struct {
	client            *Client
	postReadFunctions []func(context.Context, *Client, *UserQuery) error
	preReadFunctions  []func(context.Context, *Client, *[]*User) error
	preCountFunctions []func(context.Context, *Client, int) error
}

func NewUserReadRepository(
	client *Client,
	postReadFunctions []func(context.Context, *Client, *UserQuery) error,
	preReadFunctions []func(context.Context, *Client, *[]*User) error,
	preCountFunctions []func(context.Context, *Client, int) error,
) *UserReadRepository {
	return &UserReadRepository{
		client:            client,
		postReadFunctions: postReadFunctions,
		preReadFunctions:  preReadFunctions,
		preCountFunctions: preCountFunctions,
	}
}

func (r *UserReadRepository) runPostRead(ctx context.Context, client *Client, q *UserQuery) error {
	for _, function := range r.postReadFunctions {
		err := function(ctx, client, q)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *UserReadRepository) runPreRead(ctx context.Context, client *Client, instances *[]*User) error {
	for _, function := range r.preReadFunctions {
		err := function(ctx, client, instances)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *UserReadRepository) runPreCount(ctx context.Context, client *Client, count int) error {
	for _, function := range r.preCountFunctions {
		err := function(ctx, client, count)
		if err != nil {
			return err
		}
	}
	return nil
}

func (r *UserReadRepository) prepareQuery(
	client *Client, limit *int, offset *int, o *UserOrderInput, w *UserWhereInput,
) (*UserQuery, error) {
	var err error
	q := r.client.User.Query()
	if limit != nil {
		q = q.Limit(*limit)
	}
	if offset != nil {
		q = q.Offset(*offset)
	}
	if o != nil {
		q = o.Order(q)
	}
	if w != nil {
		q, err = w.Filter(q)
		if err != nil {
			return nil, err
		}
	}
	return q, nil
}

// using in Tx
func (r *UserReadRepository) GetWithClient(
	ctx context.Context, client *Client, w *UserWhereInput, forUpdate bool,
) (*User, error) {
	q, err := r.prepareQuery(client, nil, nil, nil, w)
	if err != nil {
		return nil, err
	}
	err = r.runPostRead(ctx, client, q)
	if err != nil {
		return nil, err
	}
	if forUpdate {
		q = q.ForUpdate()
	}
	instance, err := q.Only(ctx)
	if err != nil {
		return nil, err
	}
	instances := []*User{instance}
	err = r.runPreRead(ctx, client, &instances)
	if err != nil {
		return nil, err
	}
	if len(instances) != 1 {
		return nil, fmt.Errorf("UserReadRepository- Get - r.runPreRead: Object not found")
	}
	return instances[0], nil
}

// using in Tx
func (r *UserReadRepository) ListWithClient(
	ctx context.Context, client *Client, limit int, offset int, o *UserOrderInput, w *UserWhereInput, forUpdate bool,
) ([]*User, error) {
	q, err := r.prepareQuery(client, &limit, &offset, o, w)
	if err != nil {
		return nil, err
	}
	err = r.runPostRead(ctx, client, q)
	if err != nil {
		return nil, err
	}
	if forUpdate {
		q = q.ForUpdate()
	}
	instances, err := q.All(ctx)
	err = r.runPreRead(ctx, client, &instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (r *UserReadRepository) Count(ctx context.Context, w *UserWhereInput) (int, error) {
	q, err := r.prepareQuery(r.client, nil, nil, nil, w)
	if err != nil {
		return 0, err
	}
	err = r.runPostRead(ctx, r.client, q)
	if err != nil {
		return 0, err
	}
	count, err := q.Count(ctx)
	err = r.runPreCount(ctx, r.client, count)
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (r *UserReadRepository) Get(ctx context.Context, w *UserWhereInput) (*User, error) {
	return r.GetWithClient(ctx, r.client, w, false)
}

func (r *UserReadRepository) List(
	ctx context.Context, limit int, offset int, o *UserOrderInput, w *UserWhereInput,
) ([]*User, error) {
	return r.ListWithClient(ctx, r.client, limit, offset, o, w, false)
}
